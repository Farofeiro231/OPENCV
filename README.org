* Overview
This repository's goal is to hold my work for the Digital Image Processig course at UFRN. The programs here contained are of escalating complexity, starting with simple pixel manipulations in an image, going through video file manipulations until image frequency filtering.
* Pixel and region manipulation
Within the *pixel-manipulation* folder, there are a few simple programs. The first program (/pixels.cpp/) is a simple region manipulation one, where a strip of the image is painted in orange. The operation there performed is shown below. It works simply by opening an image file, determining a rectangular region to be written to and looping through its pixels to change their color one by one. I could certainly do this in a smarter and faster way, but the intent of the exercise was to make us used to working and manipulating pixels.

|----------------------+------------------------------|
| Original image       | Strip-modified image         |
|----------------------+------------------------------|
| [[./figuras/bolhas.png]] | [[./figuras/strip-modified.png]] |
|----------------------+------------------------------|

** Negative image

The /pixel-manip.cpp/ only opens the image passed as an argument and converts it to a grayscale image, hence I won't discuss it any further. The /regions.cpp/ program, however, is a bit more interesting; in it, the user passes an image image during the function call for the program to "negate" one portion of it; it works as follows: once the image is open, it is converted to a grayscale image (to simplify the procedure) and the user is asked for two (x, y) points, one for the upper-left corner of the negative rectangle to be created, and the other for the bottom-right corner. Once the two points are provided, every pixel within that zone has its value replace by the corresponding negative value; i.e.:

[[./figuras/negative-equation.png]]

 Below is the result of applying the negative effect to an area delimited by P1 = (50, 100) and P2 = (300, 500) on the Lenna image.

|----------------------+------------------------------|
| Original Lenna image | Modified Lenna image         |
|----------------------+------------------------------|
| [[./figuras/Lenna.png]]  | [[./figuras/negative-lenna.png]] |
|----------------------+------------------------------|

** Region-swapped image

The last program in this section is the one in the /swap-regions.cpp/ file. As its name suggests, this program takes an image and swaps its portions located in opposite quadrants (as in the for quadrants in a cartesian plan). The code mechanism is very simple; all of the work is done by the *swap_image* function: it takes the source image and the image (both are OPENCV Mat objects) that will receive the modified image resulting from the operation. Innside it, another Mat object of size of a single quadrant (i.e.: half the height and half the width of the original image) is created containing all zeros; then, one by one, the quadrants of the output image are replaced by the sum of this newly created all-zeros Mat with the opposing portion of the original image (the sum is necessary to create a new Mat object and to avoid modifying the original image in the swapping process). Running the program on the Lenna image yields the results shown bellow.

|----------------------+-----------------------------|
| Original Lenna image | Swapped Lenna image         |
|----------------------+-----------------------------|
| [[./figuras/Lenna.png]]  | [[./figuras/swapped-lenna.png]] |
|----------------------+-----------------------------|

* Labeling
This folder contains a simple program to detect and count the number of full and hollow bubbles (or contiguous regions distinct from the background) in a figure, as well as to highlight the found objects in the scene. To observe its results (which are divided in three different output images) I used the same bubbles image as the one in the previous section. Here's how the program works:

1) The user executes the program and passes an image file path as its argument;
2) The image is either open correctly - and the algorithm moves to the next step - or not, in which case the execution ends;
3) The image is then converted to a copy of itself in grayscale and displayed on screen, unaltered.
4) The grayscale copy of the image is then analyzed to have its edge objects removed (the objects touching one of the figure's four edges) - this is required since we cannot guarantee that edge objects are hollow of full, and we'll work on this later on -; therefore, all of the edge pixels are verified to look for white ones; if a white pixel is found, the OPENCV floodFill method is used to turn that whole bubble into a black one (making it disappear in the dark background);
5) After eliminating the edge bubbles, the hollow ones are now detected and have their inner edges drawn in gray. This is done by using OPENCV's findCountours method, which allows not only for contour detection, but also for the storage of the contours' hierarchical information in an array named << hierarchy >>; from this array, then, I check which contours have children (inner contours, what indicates a hollow bubble) and increment the number of hollows found;
6) Then, the bubbles are counted through the search of white pixels and the usage, once more, of the floodFill method: each found object is then counted (starting on zero) and its count number is used to replace its original gray intensity (here a problem arises: if the number of bubbles is higher than 255 - the uchar limit -, then I'd have to use an integer to count them, and another strategy to change their color);
7) To conclude, to image with the counted objects undergoes an histogram equalization (using opencv's equalizeHist method), which makes the bubble more visible (mainly the first ones detected, since their colors were replaced by very low gray intensities).


|----------------------+-------------------------------------|
| Original image       | Edgless image and contoured bubbles |
|----------------------+-------------------------------------|
| [[./figuras/bolhas.png]] | [[./figuras/edgeless-contoured.png]]    |
|----------------------+-------------------------------------|

|-----------------------+-----------------------------------|
| Counted bubbled       | Counted and Highlighted bubbles   |
|-----------------------+-----------------------------------|
| [[./figuras/counted.png]] | [[./figuras/counted-highlighted.png]] |
|-----------------------+-----------------------------------|

* Histogram manipulation
Entering now the realm of more complex manipulations and starting to work with colored images, this portion of the activity handles histogram manipulations. The first program here performs a simple histogram equalization on an image, and the second one uses the differences on frames' histograms to detect motion in a video captured scene.
** Equalization

