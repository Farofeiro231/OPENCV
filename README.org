* Overview
This repository's goal is to hold my work for the Digital Image Processig course at UFRN. The programs here contained are of escalating complexity, starting with simple pixel manipulations in an image, going through video file manipulations until image frequency filtering.
* Pixel and region manipulation
Within the *pixel-manipulation* folder, there are a few simple programs. The first program (/pixels.cpp/) is a simple region manipulation one, where a strip of the image is painted in orange. The operation there performed is shown below. It works simply by opening an image file, determining a rectangular region to be written to and looping through its pixels to change their color one by one. I could certainly do this in a smarter and faster way, but the intent of the exercise was to make us used to working and manipulating pixels.

|----------------------+------------------------------|
| Original image       | Strip-modified image         |
|----------------------+------------------------------|
| [[./figuras/bolhas.png]] | [[./figuras/strip-modified.png]] |
|----------------------+------------------------------|

** Negative image

The /pixel-manip.cpp/ only opens the image passed as an argument and converts it to a grayscale image, hence I won't discuss it any further. The /regions.cpp/ program, however, is a bit more interesting; in it, the user passes an image image during the function call for the program to "negate" one portion of it; it works as follows: once the image is open, it is converted to a grayscale image (to simplify the procedure) and the user is asked for two (x, y) points, one for the upper-left corner of the negative rectangle to be created, and the other for the bottom-right corner. Once the two points are provided, every pixel within that zone has its value replace by the corresponding negative value; i.e.:

[[./figuras/negative-equation.png]]

 Below is the result of applying the negative effect to an area delimited by P1 = (50, 100) and P2 = (300, 500) on the Lenna image.

|----------------------+------------------------------|
| Original Lenna image | Modified Lenna image         |
|----------------------+------------------------------|
| [[./figuras/Lenna.png]]  | [[./figuras/negative-lenna.png]] |
|----------------------+------------------------------|

** Region-swapped image

The last program in this section is the one in the /swap-regions.cpp/ file. As its name suggests, this program takes an image and swaps its portions located in opposite quadrants (as in the for quadrants in a cartesian plan). The code mechanism is very simple; all of the work is done by the *swap_image* function: it takes the source image and the image (both are OPENCV Mat objects) that will receive the modified image resulting from the operation. Innside it, another Mat object of size of a single quadrant (i.e.: half the height and half the width of the original image) is created containing all zeros; then, one by one, the quadrants of the output image are replaced by the sum of this newly created all-zeros Mat with the opposing portion of the original image (the sum is necessary to create a new Mat object and to avoid modifying the original image in the swapping process). Running the program on the Lenna image yields the results shown bellow.

|----------------------+-----------------------------|
| Original Lenna image | Swapped Lenna image         |
|----------------------+-----------------------------|
| [[./figuras/Lenna.png]]  | [[./figuras/swapped-lenna.png]] |
|----------------------+-----------------------------|

* Labeling
This folder contains a simple program to detect and count the number of full and hollow bubbles (or contiguous regions distinct from the background) in a figure, as well as to highlight the found objects in the scene. To observe its results (which are divided in three different output images) I used the same bubbles image as the one in the previous section. Here's how the program works:

1) The user executes the program and passes an image file path as its argument;
2) The image is either open correctly - and the algorithm moves to the next step - or not, in which case the execution ends;
3) The image is then converted to a copy of itself in grayscale and displayed on screen, unaltered.
4) The grayscale copy of the image is then analyzed to have its edge objects removed (the objects touching one of the figure's four edges) - this is required since we cannot guarantee that edge objects are hollow of full, and we'll work on this later on -; therefore, all of the edge pixels are verified to look for white ones; if a white pixel is found, the OPENCV floodFill method is used to turn that whole bubble into a black one (making it disappear in the dark background);
5) After eliminating the edge bubbles, the hollow ones are now detected and have their inner edges drawn in gray. This is done by using OPENCV's findCountours method, which allows not only for contour detection, but also for the storage of the contours' hierarchical information in an array named << hierarchy >>; from this array, then, I check which contours have children (inner contours, what indicates a hollow bubble) and increment the number of hollows found;
6) Then, the bubbles are counted through the search of white pixels and the usage, once more, of the floodFill method: each found object is then counted (starting on zero) and its count number is used to replace its original gray intensity (here a problem arises: if the number of bubbles is higher than 255 - the uchar limit -, then I'd have to use an integer to count them, and another strategy to change their color);
7) To conclude, to image with the counted objects undergoes an histogram equalization (using opencv's equalizeHist method), which makes the bubble more visible (mainly the first ones detected, since their colors were replaced by very low gray intensities).



|----------------------+-------------------------------------|
| Original image       | Edgless image and contoured bubbles |
|----------------------+-------------------------------------|
| [[./figuras/bolhas.png]] | [[./figuras/edgeless-contoured.png]]    |
|----------------------+-------------------------------------|

|-----------------------+-----------------------------------|
| Counted bubbled       | Counted and Highlighted bubbles   |
|-----------------------+-----------------------------------|
| [[./figuras/counted.png]] | [[./figuras/counted-highlighted.png]] |
|-----------------------+-----------------------------------|

* Histogram manipulation
Entering now the realm of more complex manipulations and starting to work with colored images, this portion of the activity handles histogram manipulations. The first program here performs a simple histogram equalization on an image, and the second one uses the differences on frames' histograms to detect motion in a video captured scene.
** Equalization
The equalization program (/equalize.cpp/ inside the manip-histogram folder) performs an histogram equalization on the frames captured by the default video device on the computer, and display both the original video and its equalized version on-screen. The equalized version has, as predicted, a slight delay in comparison to the original video (as it has to perform a few operations on each frame before displaying them).

The first procedure in the program is to initialize the VideoCapture object (named *cap*) on line 93 (after declaring all the other variables). If the video capture device cannot be open for whatever reason, the execution ends; however, if the device is available, the object has, then, connfigured its captured frames' height and width. On lines /110/ to /114/ are initialized the objects that will hold mini-plots of the current frame's histogram for each image (the red, blue and green histograms will, each, be displayed in a small rectangle on the top left corner of the captured image). Then, the program goes on the loop responsible for equalizing the incoming frame's histogram and showing both the original frame and the equalized version on screen.

Once inside the loop, each frame has its histogram - for each color plane - normalized and histored in the *histR*, *histG*, and *histB* variables. This is done at line 121:

#+BEGIN_SRC CPP
  equalizeHistogram(image, planes, histR, histG, histB, nbins, histrange);
#+END_SRC

The above function operates, then, splits the original image into three new images, each one containing only the information corresponding to a given color's intensity (for the red, the blue and the green colors).

#+BEGIN_SRC CPP
  cv::split(src, planes);  // src is the orignal image in the current frame and planes is an array of opencv matrices
#+END_SRC

These single-color images are then used to calculate the histogram of each color component in the original image. However, the plot will reflect the histogram trend in a simplified manner, as having one bin for each intensity (rangin from 0 to 255) would create a very large plot over the current frame; hence, I chose to use 64 bins on the histogram plot to make it smaller. Therefore, the intensity jump from one bin to its neighboor is of 4 values (e.g.: red intensities from 0 to 3 will land on the same bin, but an intensity of 4 will be in the next bin).

From the information of each color component's histogram, is calculated the accumulated histogram for each one of them, which is in turn used to equalized each color plane individually. After performing the equalization of each plane, the three of them are merged back into the original image. Here, as the original image has already been displayed on screen, there's no problem in overwriting it.

A few more steps are necessary to plot the histogram graphs on top of the equalized image. First, it is necessary to normalize each histogram to fit the size of the small plotting windows where it will be plotted. Here's how it's done:

#+begin_src cpp
    cv::normalize(histR, histR, 0, histImgR.rows, cv::NORM_MINMAX, -1, cv::Mat());
    cv::normalize(histG, histG, 0, histImgG.rows, cv::NORM_MINMAX, -1, cv::Mat());
    cv::normalize(histB, histB, 0, histImgB.rows, cv::NORM_MINMAX, -1, cv::Mat());
#+end_src

Then, the small plotting areas are set to black (lines 127 to 129) and the histograms are plotted on top of each one; there's a catch, though: as the origin of the coordinate system is on the top-left corner of the image, each bin needs to be drawn as a line going from the botttom up, as shown bellow) - this could be turned into a function for less code duplication.

#+begin_src cpp
  for(int i = 0; i < nbins; i++){
    cv::line(histImgR,
             cv::Point(i, histh),
             cv::Point(i, histh-cvRound(histR.at<float>(i))),
             cv::Scalar(0, 0, 255), 1, 8, 0);
    cv::line(histImgG,
             cv::Point(i, histh),
             cv::Point(i, histh-cvRound(histG.at<float>(i))),
             cv::Scalar(0, 255, 0), 1, 8, 0);
    cv::line(histImgB,
             cv::Point(i, histh),
             cv::Point(i, histh-cvRound(histB.at<float>(i))),
             cv::Scalar(255, 0, 0), 1, 8, 0);
   }
#+end_src

After that, each histogram's plot is copied on top of the now-equalized image and the result is shon on screen. The user can stop the program by pressing the ESC key.

Here's an example of the outputs of the program for a given frame. The equalization effect is most useful when the environment in which the pictures are taken is either too bright or too dark.

|-----------------------------------------------------------------|
| Original image (left) / Equalized image with plotted histograms |
|-----------------------------------------------------------------|
| [[./figuras/equalized_book.png]]                                    |
|-----------------------------------------------------------------|

** Histogram-based motion detector

This program is based on the previous one (the equalization program), hence, most of it works just as the the other. The difference here, however, is this: two frames are kept at a time, and their histograms are compared to verify if there are any important discrepancies; if that's the case, a red dot appears on the screen's bottom-right corner to indicate that motion has been detected.

#+begin_src cpp
  // Two images are kept at once.
  cap >> image_t;
  cap >> image_t_plus;
#+end_src

To detect any motion, the bellow function (whose name is very suggestive) is used.

#+begin_src cpp
  detect_motion(image_t, image_t_plus, planes, nbins, histrange);
#+end_src

It takes the image at instant /t/ and the image at /t + 1/ and compared their histograms. Inside the function, both frames are split into three images containing, each, a single color component (just as was done for the equalization function). Then, another function called /histogram_diff/ is used to calculate the maximum difference for each color component between the two frames.

#+begin_src cpp
  hist_max[0] = histogram_diff(histB, histB_plus);
  hist_max[1] = histogram_diff(histG, histG_plus);
  hist_max[2] = histogram_diff(histR, histR_plus);
#+end_src

These difference values are then compared with movement thresholds (set up beforehand) to check for any movement; if any one of them is higher than the given threshold, the red dot is printed on screen to indicate the detection. The bellow image shows an instant where I quickly moved the book to prompt the motion detection.


|-------------------------------|
| Motion detected               |
|-------------------------------|
| [[./figuras/motion-detected.png]] |
|-------------------------------|

* Space filtering
In this section I start dealing with masks applied to images in the space domain (without using any kind of transformation such as Fourier's transform). The first portion of this exercise comprises a simple task: to add an LoG (Laplaciann of Guassian) filter to the program created by my professor. The file in question is the /spacefilter.cpp/ inside the *space-filtering* folder.

** Laplacian-of-Gaussian filterinng

The readers can try for themselves all of the filters in the program. To swap between filters, it suffices to hit the corresponding key after launching the program (e.g.: 'b' for the boost filter, or 'l' for the laplacian filter). The program works in a very simple manner: each filter's mask is pre-defined inside the main fuction as a float-array. Then, the program goes into a loop that waits for a key press and changnes the mask applied to the image accordingly. At the beginning of each loop, the original image is filtered through the application of the selected mask via the usage of opencv's filter2D method: it applies the mask as a kernel on the original image. The masks definition is shown bellow.

#+begin_src cpp
  float media[] = {0.1111, 0.1111, 0.1111, 0.1111, 0.1111,
                   0.1111, 0.1111, 0.1111, 0.1111};
  float gauss[] = {0.0625, 0.125,  0.0625, 0.125, 0.25,
                   0.125,  0.0625, 0.125,  0.0625};
  float vertical[] = {-1, 0, 1, -2, 0, 2, -1, 0, 1};
  float horizontal[] = {-1, -2, -1, 0, 0, 0, 1, 2, 1};
  float laplacian[] = {0, -1, 0,
                       -1, 4, -1,
                       0, -1, 0};
  float boost[] = {0, -1, 0,
                   -1, 5.2, -1,
                   0, -1, 0};
  float LoG[] = {0, 0, 1, 0, 0,
                 0, 1, 2, 1, 0,
                 1, 2, -16, 2, 1,
                 0, 1, 2, 1, 0,
                 0, 0, 1, 0, 0};
#+end_src

To implement the Laplacian-of-Gaussian filter, I simply used this widely known mask and added another option for the the case selection inside the main loop.

#+begin_src cpp
  case 'p':
  // The performance of the LoG is further improved by filtering it
  // with the average mask afterwards.
  mask = cv::Mat(5, 5, CV_32F, LoG);
  printmask(mask);
  break;
#+end_src

The images bellow show a comparison between the Laplacian and the LoG filters applied to the book image. As we can see, the LoG filter sharpens the contours of the image at the cost of being more sensitive to noise.


|-------------------------+--------------------|
| Guassian-filtered image | LoG-filtered image |
|-------------------------+--------------------|
| [[./figuras/laplacian.png]] | [[./figuras/log.png]]  |
|-------------------------+--------------------|

** Image tilt-shifting
